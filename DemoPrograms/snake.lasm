# global vars
# stack: 0x00 to 0x7F
.HEAD_X         0x80
.HEAD_Y         0x81
.TAIL_X         0x82
.TAIL_Y         0x83
.HEAD_IDX       0x84    # Head & tail indices of the circular queue. New directions are added at the head
.TAIL_IDX       0x85
.HEAD_DIR       0x8F
.BODY_DIRS      0x90    # to 0x9F. Each byte stores 4 direction, each one crumb. Crumb 0 is at the least significant position
.SCREEN_STATE   0xA0    # to 0xA7. Each byte stores the 8 pixels of the row. Pixel 0 is MSB of each row
.APPLE_X        0xB0
.APPLE_Y        0xB1

# ---------------------------------------------------------------------------------------------------------------------
# void main()
# [r3 - 1] = headX
# [r3 - 2] = headY
# [r3 - 3] = headIdx >> 2
# [r3 - 4] = random
# [r3 - 5] = newAppleX
# [r3 - 6] = newAppleY
# [r3 - 7] = ateApple

incr3 7

# Initialize snake and screen

store0 HEAD_DIR
store0 TAIL_IDX

store0 SCREEN_STATE         # Empty lines of screen
store0 [SCREEN_STATE + 1]
store0 [SCREEN_STATE + 2]
store0 [SCREEN_STATE + 4]
store0 [SCREEN_STATE + 6]
store0 [SCREEN_STATE + 7]

set0 0b01110000             # Non-empty lines of screen
store0 [SCREEN_STATE + 3]
set0 0b00000010
store0 [SCREEN_STATE + 5]

set0 0b00001111
store0 BODY_DIRS    # 1st and 2nd body part directions

set0 3              # Head/tail position
store0 HEAD_X
store0 HEAD_Y
store0 TAIL_Y

set0 2
store0 HEAD_IDX

set0 1
store0 TAIL_X

set0 6
store0 APPLE_X
set0 5
store0 APPLE_Y

# Show initial screen state
dispi SCREEN_STATE
disp8

# Wait for player input to start. Also obtain a seed for the RNG (stored in r2)
start:
input r0
incr2 1
jif0 start
sloc1 -4

# Main game loop
main_loop:

# Determine new head direction (r0)
input r2
set1 0x0F
gr r0 r1 r2
jifn dir_change_end         # No directional input -- direction unchanged
mov r0 r2

set1 3                     # Increment r1 until MSB of r0 is 1
jump get_dir_cond
get_dir_loop:
add r0 r0 r0
incr1 -1
get_dir_cond:
jifn get_dir_loop
store1 HEAD_DIR
dir_change_end:

# Determine new head position & store on stack. (r0 = x, r1 = y)
load0 HEAD_DIR
call dir_to_delta_xy
set4 0x07                   # Mask = 0000_0111. Used to mod head position by screen size
load0 HEAD_X
add r1 r0 r1
and r0 r1 r4
load1 HEAD_Y
add r2 r1 r2
and r1 r2 r4
sloc0 -1
sloc1 -2

# Check if apple was eaten
load2 APPLE_X
eq r0 r0 r2
load2 APPLE_Y
eq r1 r1 r2
and r0 r1 r0
sloc0 -7
jifn did_not_eat_apple

# If apple was eaten, generate new apple position
gen_apple_pos_loop:
lloc0 -4                # Get new random state
call gen_random
sloc0 -4

set2 0x07               # Mask
and r1 r0 r2            # Get position based on random state
sloc1 -6
shr r0 r0
shr r0 r0
shr r0 r0
and r0 r0 r2
sloc0 -5

call get_pixel          # If pixel at new apple is already filled, regenerate
jifn0 gen_apple_pos_loop

lloc0 -5                # Set apple position
store0 APPLE_X
lloc0 -6
store0 APPLE_Y

addro0 SCREEN_STATE     # Color in pixel of new apple position
loadi r2
or r2 r2 r1
storei r2

jump move_head

did_not_eat_apple:

# Get state of pixel at new head position
lloc1 -2
lloc0 -1
call get_pixel

# If pixel is nonempty, game over
jifn0 game_over

# Color in pixel of new head position
lloc0 -2
addro0 SCREEN_STATE
loadi r2
or r2 r2 r1
storei r2

move_head:

# Move head to new position. Do this after checking lose condition in the interest of a cleaner game over animation
lloc0 -2
lloc1 -1
store1 HEAD_X
store0 HEAD_Y

# Load block of bodyDir containing the head pointer
load2 HEAD_DIR
load1 HEAD_IDX
set4 0x03
and r0 r1 r4
shr r1 r1
shr r1 r1
sloc1 -3
addro1 BODY_DIRS
loadi r4

# Add the new head direction to the block
set1 0x03
# Curr registers: r0 = body dir sub index, r1 = mask, r2 = head dir, r4 = body dir block
jump head_append_cond
head_append_loop:
add r2 r2 r2
add r2 r2 r2
add r1 r1 r1
add r1 r1 r1
incr0 -1
head_append_cond:
jifn0 head_append_loop
not r1 r1
and r4 r1 r4
or r1 r2 r4

# Write the block back to memory
lloc0 -3
addro0 BODY_DIRS
storei r1

# Increment head index
load0 HEAD_IDX
incr0 1
set4 0x0F
and r0 r0 r4
store0 HEAD_IDX

# If an apple was eaten, do not move the tail
lloc0 -7
jifn0 main_loop_end

# Uncolor pixel containing the tail
load0 TAIL_X
load1 TAIL_Y
addro1 SCREEN_STATE
loadi r2

set1 0x80                 # Build mask
jump tail_uncolor_cond
tail_uncolor_loop:
shr r1 r1
incr0 -1
tail_uncolor_cond:
jifn0 tail_uncolor_loop

not r1 r1
and r2 r2 r1
load1 TAIL_Y
addro1 SCREEN_STATE
storei r2

# Get the direction of the last item in the body directions queue
load1 TAIL_IDX          # Load block containing the direction
set4 0x03
and r0 r1 r4
shr r1 r1
shr r1 r1
addro1 BODY_DIRS
loadi r1

jump move_tail_cond     # Extract direction
move_tail_loop:
shr r1 r1
shr r1 r1
incr0 -1
move_tail_cond:
jifn0 move_tail_loop
set4 0x03
and r0 r1 r4

# Compute new tail position
call dir_to_delta_xy
set4 0x07
load0 TAIL_X
add r1 r0 r1
and r1 r1 r4
store1 TAIL_X
load0 TAIL_Y
add r2 r0 r2
and r2 r2 r4
store2 TAIL_Y

# Increment tail index
load0 TAIL_IDX
incr0 1
set4 0x0F
and r0 r0 r4
store0 TAIL_IDX


# Show the screen
main_loop_end:
dispi SCREEN_STATE
disp8

jump main_loop

game_over:
halt    # TODO: game over animation



# ---------------------------------------------------------------------------------------------------------------------
# Converts a 2-bit direction (r0) to delta X (r1) and delta Y (r2) values
# Direction order: Up, Down, Left, Right (Helpful to remember Konami code)
#
# (char, char) dirToDeltaXY(char dir)

dir_to_delta_xy:
set1 0                      # dir 0 = up
set2 -1

jif0 dir_to_delta_xy_end
incr0 -1                    # dir 1 = down
set2 1

jif0 dir_to_delta_xy_end
incr0 -1                    # dir 2 = left
set1 -1
set2 0

jif0 dir_to_delta_xy_end
set1 1                      # dir 3 = right

dir_to_delta_xy_end:
ret 0

# ---------------------------------------------------------------------------------------------------------------------
# Gets the state of a pixel on the screen. Returns nonzero if the pixel is on and zero if the pixel is off. Also
# returns the mask used to extract the pixel
#
# (char state, char mask) get_pixel(char x, char y)

get_pixel:
# Get screen state of row containing pixel (r2 = row state)
addro1 SCREEN_STATE                 
loadi r2

# Build mask used to extract pixel (i.e. set r1 to be 1000_0000 >> x)
set1 0x80
jump extract_cond
extract_start:
shr r1 r1
incr0 -1
extract_cond:
jifn0 extract_start

and r0 r1 r2
ret 0

# ---------------------------------------------------------------------------------------------------------------------
# Linear-feedback shift register PRNG. Based on https://www.codebase64.org/doku.php?id=base:small_fast_8-bit_prng
#
# char gen_random(char state)

gen_random:
jif0 do_xor         # Special case: 0x00 maps to 0x1D

add r0 r0 r0
jif0 skip_xor       # Special case: 0x80 maps to 0x00
jifn skip_xor

do_xor:
set1 0x1D
xor r0 r0 r1

skip_xor:
ret 0
